---
title: "Модуль descheduler"
---

Модуль запускает в кластере [descheduler](https://github.com/kubernetes-incubator/descheduler/) с набором [стратегий](#стратегии), заданных в custom resource `Descheduler`.

Descheduler каждые 15 минут удаляет поды, соответствующие стратегиям, указанным в пользовательском ресурсе `Descheduller`. Это инициирует принудительное выполнение процесса планирования для удаленных подов.

## Особенности работы descheduler

* При вытеснении подов с нагруженного узла учитывается класс приоритета (ознакомьтесь с модулем [priority-class](../001-priority-class/)).
* Поды с [priorityClassName](../001-priority-class/) `system-cluster-critical` или `system-node-critical` (*критичные* поды) не вытесняются.
* Поды без контроллера или с контроллером DaemonSet не вытесняются.
* Поды с local storage не вытесняются.
* Best-effort-поды вытесняются раньше, чем Burstable и Guaranteed.
* Учитывается [Pod Disruption Budget](https://kubernetes.io/docs/concepts/workloads/pods/disruptions/): если вытеснение пода приведет к нарушению условий PDB, то под не вытесняется.

## Стратегии

Включить, выключить и настроить стратегии можно в custom resource [`Descheduler`](cr.html).

### HighNodeUtilization

Эта стратегия определяет ненагруженные узлы и перемещает с них поды, ожидая, что эти поды будут равномерно распределены по меньшему количеству узлов. Эту стратегию следует использовать со стратегией планировщика `MostRequestedPriority`.

### LowNodeUtilization

Эта стратегия определяет нагруженные и ненагруженные узлы в кластере на основе данных о CPU, памяти и подах (в процентах), и при наличии обоих типов узлов перемещает поды с нагруженных узлов, ожидая, что они будут запущены на ненагруженных. Эта стратегия учитывает не фактическое использование ресурсов на узле, а запросы от подов.

### PodLifeTime

Эта стратегия гарантирует удаление подов  с узлов в состоянии `Pending` старше 24 часов.

### RemoveDuplicates

Эта стратегия отслеживает, чтобы на одном узле не было запущенно более одного пода одного контроллера (RS, RC, Deploy, Job). Если подов два на одном узле, descheduler удаляет один под.

Например, если присутсвует 3 узла (один из них более нагружен), и необходимо предоставить 6 реплик приложения, так как один узел перегружен, scheduler привяжет к нагруженному узлу 1 под или не привяжет ни одного. Остальные реплики будут перемещены на другие узлы. Descheduller каждые 15 минут будет удалять "лишние" поды на ненагруженных узлах, ожидая, что планировщик привяжет их к данному нагруженному узлу.

### RemovePodsHavingTooManyRestarts

Эта стратегия гарантирует, что поды, имеющие больше 100 перезапусков контейнеров (включая init-контейнеры), будут удалены с узлов.

### RemovePodsViolatingInterPodAntiAffinity

Эта стратегия обеспечивает удаление всех "нарушителей" anti-affinity и гарантирует, что поды, нарушающие anti-affinity interpod, будут удалены из узлов. Например, если на узле есть под A, а под B и под C (запущенные на одном узле) имеют правила anti-affinity, которые запрещают им запускаться на одном узле, тогда под A будет удален с узла, чтобы под B и под C могли запускаться. Эта проблема может возникнуть, когда правила anti-affinity подов B, C создаются, когда они запущены на узле.

### RemovePodsViolatingNodeAffinity

Эта стратегия отвечает за кейс, когда под был привязан к узлу по условиям (`requiredDuringSchedulingIgnoredDuringExecution`), но потом узел перестал им удовлетворять. Тогда descheduler увидит это и сделает все, чтобы под переехал туда, где он будет удовлетворять условиям.

### RemovePodsViolatingNodeTaints

Эта стратегия гарантирует, что поды, нарушающие NoSchedule на узлах, будут удалены. Например, есть под, имеющий toleration и запущенный на узле с соответствующим taint. Если taint на узле будет изменен или удален, под будет вытеснен с узла.

### RemovePodsViolatingTopologySpreadConstraint

Эта стратегия гарантирует, что поды, нарушающие [Pod Topology Spread Constraints](https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/), будут вытеснены с узлов.
